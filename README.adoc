= Fractor: Function-driven Ractors framework

image:https://img.shields.io/gem/v/fractor.svg[RubyGems Version, link=https://rubygems.org/gems/fractor]
image:https://img.shields.io/github/license/metanorma/fractor.svg[License, link=https://github.com/metanorma/fractor/blob/main/LICENSE]
image:https://github.com/metanorma/fractor/actions/workflows/rake.yml/badge.svg[Build Status, link=https://github.com/metanorma/fractor/actions/workflows/rake.yml]
image:https://img.shields.io/badge/ruby-3.0%20%E2%86%92%204.0%2B-ruby.svg[Ruby 3.0 to 4.0+, link=https://www.ruby-lang.org]

Fractor is a lightweight Ruby framework for parallel processing using Ractors
(Ruby Actors).

It provides a structured way to distribute computational work across multiple
Ractors with minimal boilerplate.

== Ruby version support

Fractor fully supports both **Ruby 3.x** and **Ruby 4.0+**:

* *Ruby 3.0+*: Uses `Ractor.yield` for message passing from workers

* *Ruby 4.0+*: Uses `Ractor::Port` for more efficient communication patterns

Fractor automatically detects your Ruby version and uses the appropriate
internal implementation. The user-facing API is identical across versions --
write your code once, and Fractor handles the differences internally.

See
link:docs/_pages/architecture.adoc#ruby-version-compatibility[Architecture: Ruby Version Compatibility]
for details on the internal differences.

== Quick start

=== Installation

[source,sh]
----
gem install fractor
----

See link:docs/_pages/installation.adoc[Installation Guide] for more options.

=== 30-second example

[source,ruby]
----
require 'fractor'

# Define your work
class MyWork < Fractor::Work
  def initialize(value)
    super({ value: value })
  end

  def value
    input[:value]
  end
end

# Define your worker
class MyWorker < Fractor::Worker
  def process(work)
    result = work.value * 2
    Fractor::WorkResult.new(result: result, work: work)
  rescue => e
    Fractor::WorkResult.new(error: e.message, work: work)
  end
end

# Create supervisor and process work
supervisor = Fractor::Supervisor.new(
  worker_pools: [{ worker_class: MyWorker }]
)

supervisor.add_work_items([
  MyWork.new(1),
  MyWork.new(2),
  MyWork.new(3)
])

supervisor.run

puts "Results: #{supervisor.results.results.map(&:result)}"
# => Results: [2, 4, 6]
----

=== Timeout Configuration

Fractor supports flexible timeout configuration at three levels:

[cols="1,2,4"]
|===
|Level |Syntax |Description

|Global
|`Fractor.configure`
|Sets default timeout for all workers

|Worker
|`Worker.timeout` class method
|Sets timeout for all work processed by a worker

|Work item
|`Work.new(input, timeout: N)`
|Overrides worker timeout for specific work item
|===

[source,ruby]
----
# 1. Global default (optional)
Fractor.configure do |config|
  config.default_worker_timeout = 60  # 60 seconds
end

# 2. Worker-level timeout
class FastWorker < Fractor::Worker
  timeout 10  # 10 second timeout for this worker

  def process(work)
    Fractor::WorkResult.new(result: work.input * 2, work: work)
  end
end

# 3. Per-work-item timeout (overrides worker timeout)
class MyWork < Fractor::Work
  def initialize(value, timeout: nil)
    super({ value: value }, timeout: timeout)
  end
end

supervisor = Fractor::Supervisor.new(
  worker_pools: [{ worker_class: FastWorker }]
)

# Mix work items with different timeouts
fast_work = MyWork.new(1, timeout: 5)      # 5 seconds
normal_work = MyWork.new(2)                 # uses worker's 10s timeout
slow_work = MyWork.new(3, timeout: 30)     # 30 seconds

supervisor.add_work_items([fast_work, normal_work, slow_work])
supervisor.run
----

When a timeout occurs, the work item is marked as failed with `error_category: :timeout` and can be retried if using the workflow system.

== Key features

* *Function-driven*: Define processing logic by subclassing `Fractor::Worker`
* *Parallel execution*: Work automatically distributed across Ractor workers
* *Two operating modes*:
  ** **Pipeline mode** for batch processing
  ** **Continuous mode** for long-running servers
* *Workflow system*: GitHub Actions-style declarative workflows
* *Error handling*: Retry logic, circuit breakers, dead letter queues, error reporting
* *Production-ready*: Signal handling, logging, monitoring, graceful shutdown
* *Performance tools*: Built-in monitoring, benchmarking, and error analytics
* *High-level primitives*: WorkQueue and ContinuousServer eliminate boilerplate

== Documentation

=== Getting started

* link:docs/_pages/installation.adoc[Installation] - System requirements and installation methods
* link:docs/_pages/getting-started.adoc[Getting Started] - Quick start guides for both modes
* link:docs/_pages/core-concepts.adoc[Core Concepts] - Understanding Fractor components

=== Operating modes

* link:docs/_guides/pipeline-mode.adoc[Pipeline Mode] - Batch processing with predefined work
* link:docs/_guides/continuous-mode.adoc[Continuous Mode] - Long-running servers and streaming

=== Advanced features

* link:docs/_features/workflows.adoc[Workflows] - Declarative workflow system for complex pipelines
* link:docs/_features/error-handling.adoc[Error Handling] - Retry logic, circuit breakers, and dead letter queues
* link:docs/_features/monitoring.adoc[Monitoring] - Performance monitoring and metrics
* link:docs/_features/signal-handling.adoc[Signal Handling] - Process monitoring and graceful shutdown

=== Reference

* link:docs/_reference/api.adoc[API Reference] - Complete API documentation
* link:docs/_reference/examples.adoc[Examples] - Complete examples for all patterns
* link:docs/_reference/troubleshooting.adoc[Troubleshooting] - Common issues and solutions

== Operating modes

Fractor supports two distinct modes:

[cols="1,2,2",options="header"]
|===
|Mode |Best for |Example use cases

|*Pipeline Mode*
|Batch processing, one-time jobs
|File processing, ETL pipelines, data transformations

|*Continuous Mode*
|Long-running servers, streaming
|Chat servers, job processors, event streams
|===

See link:docs/getting-started.adoc#choosing-your-mode[Choosing Your Mode] for detailed guidance.

== Example applications

=== Pipeline mode

[source,ruby]
----
supervisor = Fractor::Supervisor.new(
  worker_pools: [{ worker_class: DataWorker }]
)

supervisor.add_work_items(dataset.map { |item| DataWork.new(item) })
supervisor.run

puts "Processed #{supervisor.results.results.size} items"
----

See link:examples/simple/[Simple Example] and link:docs/examples.adoc#pipeline-mode-examples[more examples].

=== Continuous mode

[source,ruby]
----
work_queue = Fractor::WorkQueue.new

server = Fractor::ContinuousServer.new(
  worker_pools: [{ worker_class: MessageWorker, num_workers: 4 }],
  work_queue: work_queue
)

server.on_result { |result| puts "Processed: #{result.result}" }
server.on_error { |error| puts "Error: #{error.error}" }

Thread.new { server.run }

# Add work dynamically
work_queue << MessageWork.new(client_id: 1, message: "Hello")
----

See link:examples/continuous_chat_fractor/[Chat Server Example] and link:docs/examples.adoc#continuous-mode-examples[more examples].

=== Workflows

[source,ruby]
----
# Define workflow with simplified syntax
workflow = Fractor::Workflow.define("data-pipeline") do
  job :extract, ExtractWorker
  job :transform, TransformWorker, needs: :extract
  job :load, LoadWorker, needs: :transform
end

# Execute workflow
result = workflow.new.execute(input_data)
----

See link:examples/workflow/simplified/README.adoc[Simplified Workflows] and link:docs/workflows.adoc[Workflow Guide].

== Production deployment

Fractor includes production-ready features:

* **Signal handling**: SIGTERM, SIGINT, SIGUSR1/SIGBREAK
* **Graceful shutdown**: Complete in-progress work before exit
* **Process monitoring**: Runtime status via signals
* **Structured logging**: JSON logging with correlation IDs
* **Workflow visualization**: Mermaid, DOT, ASCII diagrams

See link:docs/signal-handling.adoc[Signal Handling Guide] for deployment patterns.

== Contributing

Bug reports and pull requests are welcome on GitHub at https://github.com/metanorma/fractor.

== License

The gem is available as open source under the terms of the Ribose BSD 2-Clause License.

== Copyright

Copyright Ribose.
