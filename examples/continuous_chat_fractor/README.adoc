= Continuous Chat Server Example (Fractor-based)

== Overview

This example demonstrates Fractor's continuous mode feature with a chat server implementation. Unlike the plain socket implementation in `examples/continuous_chat_server/`, this version uses Fractor's Worker and Supervisor classes to process chat messages concurrently.

The example shows how to:

* Use Fractor in continuous mode (`continuous_mode: true`)
* Register work source callbacks with `register_work_source`
* Process messages asynchronously using Ractor-based workers
* Coordinate between main thread socket handling and Fractor workers
* Implement graceful shutdown

== Key Concepts

* *Continuous Mode*: The Fractor supervisor runs indefinitely, processing work as it arrives
* *Work Sources*: Callback functions that provide new work items to the supervisor on demand
* *Asynchronous Processing*: ChatWorker processes messages concurrently in Ractors
* *Thread Coordination*: Multiple threads working together - main thread handles I/O, Fractor workers process messages
* *Message Logging*: All message processing is logged to demonstrate Fractor's work distribution

== Architecture

=== Fractor Components

The server uses the following Fractor components:

1. *ChatMessage (Fractor::Work)*: Represents a chat message as a unit of work
   - Encapsulates the message packet and optional client socket reference
   - Each message becomes a work item in the Fractor queue

2. *ChatWorker (Fractor::Worker)*: Processes chat messages
   - Runs in a Ractor for parallel processing
   - Handles different message types (broadcast, direct_message, server_message, user_list)
   - Returns WorkResult with processing outcome

3. *Supervisor*: Orchestrates the workers
   - Configured with `continuous_mode: true` to run indefinitely
   - Uses 2 worker Ractors (auto-detected from system processors)
   - Registered work source pulls from a thread-safe Queue

=== Thread Architecture

The server uses three concurrent components:

1. *Main Thread*: Handles socket I/O with `IO.select`
   - Accepts new client connections
   - Reads messages from client sockets
   - Sends responses back to clients
   - Puts received messages into the work queue

2. *Supervisor Thread*: Runs the Fractor supervisor
   - Continuously pulls work from the queue via the work source callback
   - Distributes work to available ChatWorker Ractors
   - Collects results in the ResultAggregator

3. *Results Thread*: Processes completed work
   - Monitors the ResultAggregator for new results
   - Logs processing outcomes
   - Handles errors from workers

== Example Components

1. *chat_common.rb*: Shared code with Fractor classes
   * `MessagePacket` class for message protocol
   * `MessageProtocol` module for serialization
   * `ChatMessage` class extending `Fractor::Work`
   * `ChatWorker` class extending `Fractor::Worker`

2. *chat_server.rb*: Fractor-based chat server
   * Socket handling in main thread
   * Fractor supervisor in continuous mode
   * Work source callback pulling from Queue
   * Results processing thread

3. *chat_client.rb*: Simple chat client (reused from plain example)
   * Connects to server via TCP socket
   * Sends and receives JSON messages

4. *simulate.rb*: Automated simulation
   * Creates server and multiple clients as processes
   * Runs predefined message schedule
   * Analyzes logs after completion

== Running the Example

=== Running the Simulation

To run the complete automated simulation:

[source,sh]
----
ruby examples/continuous_chat_fractor/simulate.rb
----

Optional parameters:
* `-p, --port PORT` - Specify server port (default: 3000)
* `-d, --duration SECONDS` - Duration of simulation in seconds (default: 10)
* `-l, --log-dir DIR` - Directory for log files (default: logs)
* `-h, --help` - Show help message

=== Running Server and Clients Separately

Run the server in one terminal:

[source,sh]
----
ruby examples/continuous_chat_fractor/chat_server.rb [PORT] [LOG_FILE]
----

Run clients in different terminals:

[source,sh]
----
ruby examples/continuous_chat_fractor/chat_client.rb [USERNAME] [PORT] [LOG_FILE]
----

== Features Demonstrated

* *Continuous Mode*: Supervisor runs indefinitely without stopping
* *Work Source Callback*: Dynamically provides work from a Queue
* *Concurrent Processing*: Multiple Ractor workers process messages in parallel
* *Thread Coordination*: Main thread, supervisor thread, and results thread work together
* *Message Logging*: All operations logged to files for verification
* *Graceful Shutdown*: Proper cleanup of Fractor supervisor and sockets

== Comparison with Plain Socket Implementation

The plain socket implementation (`examples/continuous_chat_server/`) uses:
- `IO.select` for non-blocking I/O
- Sequential message processing in the main thread
- Simple, straightforward architecture

The Fractor-based implementation demonstrates:
- Parallel message processing using Ractors
- Work queue pattern with work source callbacks
- Separation of concerns (I/O vs processing)
- Continuous mode supervisor pattern

Both implementations are functional. The Fractor version shows how to structure a long-running server using Fractor's continuous mode, which is useful for:
- CPU-intensive message processing
- Scaling message handling across cores
- Separating I/O from computation
- Learning Fractor's continuous mode patterns

== Expected Output

The simulation will show:
* Fractor supervisor starting with workers
* Clients connecting to the server
* Messages being sent between clients
* Messages being added to Fractor work queue (logged as "Received from...")
* Graceful shutdown of all components

NOTE: In this implementation, Fractor workers process messages in parallel for demonstration purposes (analyzing message types, logging processing), while the main thread handles actual message delivery to ensure real-time responsiveness. The work items are successfully queued and processed by workers - you can verify this by seeing that all messages are correctly broadcast/delivered to clients.

== Log Files

After running the simulation, check the `logs/` directory:

* `server_messages.log` - Server activity and Fractor processing
* `client_<username>_messages.log` - Client activity
* `client_<username>_send_messages.json` - Messages sent by client

== Implementation Notes

=== Why Thread-safe Queue?

The implementation uses Ruby's `Queue` class (thread-safe) to coordinate between:
- Main thread (producing work from socket I/O)
- Supervisor thread (consuming work via work source callback)

This is necessary because Ractors cannot directly share mutable objects with threads.

=== Work Source Callback

The work source callback pulls up to 5 messages from the queue at once:

[source,ruby]
----
supervisor.register_work_source do
  messages = []
  5.times do
    break if message_queue.empty?
    msg = message_queue.pop(true) rescue nil
    messages << msg if msg
  end
  messages.empty? ? nil : messages
end
----

This batching improves efficiency by reducing callback overhead.

=== Results Processing

A separate thread monitors the ResultAggregator because:
- The main thread is busy with socket I/O
- The supervisor thread is running `supervisor.run`
- We want to log results as they complete

In a production system, you might process results differently (e.g., send notifications, update databases, etc.).

== Continuous Mode Benefits

This example demonstrates key benefits of Fractor's continuous mode:

1. *Non-stopping Execution*: Server runs indefinitely, processing messages as they arrive
2. *Dynamic Work Addition*: Work source callback provides new work on demand
3. *Resource Efficiency*: Workers idle when no work available
4. *Parallel Processing*: Multiple messages processed concurrently
5. *Graceful Shutdown*: `supervisor.stop` cleanly terminates workers

== See Also

* link:../continuous_chat_server/[Plain Socket Implementation] - Simpler approach without Fractor
* link:../../README.adoc#continuous-mode[Main README Continuous Mode Section]
