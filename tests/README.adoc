= Fractor: Function-driven Ractors framework

.Foreword
This document describes Fractor, a lightweight Ruby framework designed to
simplify the process of distributing computational work across multiple Ractors.

== Introduction

Fractor stands for *Function-driven Ractors framework*. It is a lightweight Ruby
framework designed to simplify the process of distributing computational work
across multiple Ractors (Ruby's actor-like concurrency model).

The primary goal of Fractor is to provide a structured way to define work,
process it in parallel using Ractors, and aggregate the results, while
abstracting away much of the boilerplate code involved in Ractor management and
communication.

=== Key concepts

* *Function-driven:* You define the core processing logic by subclassing
  `Fractor::Worker` and implementing the `process` method.

* *Parallel execution:* Work items are automatically distributed to available
  worker Ractors for concurrent processing.

* *Result aggregation:* The framework collects both successful results and
  errors from the workers.

* *Separation of concerns:* Keeps the framework logic (`fractor.rb`) separate
  from the client's specific implementation (`sample.rb`).

== Scope

This document covers the design, implementation, and usage of the Fractor
framework. It provides detailed information about the framework's components,
their interactions, and how to use them to implement parallel processing in Ruby
applications.

[bibliography]
== Normative references

* [[[ruby,Ruby Programming Language]]], https://www.ruby-lang.org/

== Terms and definitions

=== Ractor
A concurrent programming abstraction in Ruby that enables parallel execution
with thread safety.

[.source]
<<ruby>>

=== Worker
A class that defines the processing logic for work items.

=== Work
A unit of computation to be processed by a Worker.

=== Work result
The output produced by a Worker after processing a Work item.

== Core components

The Fractor framework consists of the following main classes, all residing
within the `Fractor` module:

* `Fractor::Worker`:

** The abstract base class for defining how work should be processed.

** Client code must subclass this and implement the `process(work)` method.

** The `process` method receives a `Fractor::Work` object (or a subclass) and
   should return a `Fractor::WorkResult` object.

* `Fractor::Work`:

** The abstract base class for representing a unit of work.

** Typically holds the input data needed by the `Worker`.

** Client code should subclass this to define specific types of work items.

* `Fractor::WorkResult`:

** A container object returned by the `Worker#process` method.

** Holds either the successful `:result` of the computation or an `:error`
   message if processing failed.

** Includes a reference back to the original `:work` item.

** Provides a `success?` method.

* `Fractor::ResultAggregator`:

** Collects and stores all `WorkResult` objects generated by the workers.

** Separates results into `results` (successful) and `errors` arrays.

* `Fractor::WrappedRactor`:

** Manages an individual Ruby `Ractor`.

** Instantiates the client-provided `Worker` subclass within the Ractor.

** Handles receiving `Work` items, calling the `Worker#process` method, and
   yielding `WorkResult` objects (or errors) back to the `Supervisor`.

* `Fractor::Supervisor`:

** The main orchestrator of the framework.

** Initializes and manages a pool of `WrappedRactor` instances.

** Manages a `work_queue` of input data.

** Distributes work items (wrapped in the client's `Work` subclass) to available
   Ractors.

** Listens for results and errors from Ractors using `Ractor.select`.

** Uses `ResultAggregator` to store outcomes.

** Handles graceful shutdown on `SIGINT` (Ctrl+C).

== Usage guide

. *Define your work item:*
+
Create a class that inherits from `Fractor::Work`. This class represents the
data structure for a single piece of work.

[source,ruby]
----
# In your client code (e.g., sample.rb)
require_relative 'fractor'

class MyWork < Fractor::Work
  def initialize(input)
    super(input) # Pass input to the base class
  end

  def to_s
    "MyWork: #{@input}"
  end
end
----

. *Define your worker logic:*
+
Create a class that inherits from `Fractor::Worker`. Implement the
`process(work)` method, which contains the core logic for handling a work item.
This method *must* return a `Fractor::WorkResult` object.
+
The framework handles two types of errors:

* *Handled errors:* These are errors that your Worker explicitly checks for and
  decides how to handle. You can return a `WorkResult` with an error message for
  these cases.

* *Unexpected errors:* These are errors that occur during processing that your
  Worker doesn't explicitly handle. These are caught by the rescue block and
  automatically converted to error results.

[source,ruby]
----
# In your client code (e.g., sample.rb)
class MyWorker < Fractor::Worker
  def process(work)
    puts "Working on '#{work.inspect}'"
    # 'work' is an instance of your Fractor::Work subclass (e.g., MyWork)

    if work.input == 5 # Example of a handled error condition
      return Fractor::WorkResult.new(error: "Cannot process 5", work: work)
    end

    # Perform computation
    calculated = work.input * 2

    # Return a successful result
    Fractor::WorkResult.new(result: calculated, work: work)
  rescue StandardError => e
    # Catch unexpected errors and return an error result
    Fractor::WorkResult.new(error: e.message, work: work)
  end
end
----

. *Initialize and run the supervisor:*
+
In your main execution script:
+
* Require the `fractor.rb` file.
* Instantiate `Fractor::Supervisor`, passing your custom `worker_class` and
  `work_class`. You can also specify the `num_workers`.
* Add raw work data using `supervisor.add_work(items)`. The supervisor will wrap
  these in your `Work` subclass instances before sending them to workers.
* Call `supervisor.run` to start the processing.
* Access the aggregated results via `supervisor.results`.

[source,ruby]
----
# In your client code (e.g., sample.rb)
if __FILE__ == $0
  # Initialize the Supervisor
  supervisor = Fractor::Supervisor.new(
    worker_class: MyWorker,   # Your worker class
    work_class: MyWork,     # Your work class
    num_workers: 4          # Number of Ractors to use
  )

  # Add work items (provide the raw input data)
  work_items = (1..20).to_a
  supervisor.add_work(work_items)

  # Start the processing loop
  supervisor.run

  # Processing is complete
  puts "Processing complete."
  puts "Final Aggregated Results:"
  puts supervisor.results.inspect

  # Access errors specifically
  failed_items = supervisor.results.errors
  puts "\nFailed Work Items (#{failed_items.size}):"
  puts failed_items.map(&:inspect).inspect
end
----

== Running the example

. Save the framework code as `fractor.rb`.

. Save the client code (including `MyWork`, `MyWorker`, and the main execution
  block) as `sample.rb` in the same directory.

. Run the sample from your terminal:

[source,sh]
----
ruby sample.rb
----

You will see output showing Ractors starting, receiving work, processing it, and
the final aggregated results, including any errors encountered. Press `Ctrl+C`
during execution to test the graceful shutdown.

[bibliography]
== Bibliography

* [[[concurrent-ruby,Concurrent Ruby]]], https://github.com/ruby-concurrency/concurrent-ruby
* [[[ruby-ractor,Ruby Ractor Documentation]]], https://docs.ruby-lang.org/en/master/Ractor.html
